# ---------------------------------------------------------------------------
# procSSURGO.py
# Version: ArcPro / Python 3+
# Creation Date: 2020-05-19
# Last Edit: 2020-11-19
# Creator: Kirsten R. Hazler
#
# Summary: Functions for processing SSURGO data and producing rasters representing soil conditions, as well as functions inspired by OpenNSPECT software to produce rasters representing interactions between soils, topography, and land cover.
#
# Adapted from toolbox tools and scripts used to produce the 2017 edition of the ConservationVision Watershed Model, and from information about the OpenNSPECT tool.
# For background references and formulas, see: 
# - Virginia ConservationVision Watershed Model, 2017 Edition (NHTR 18-16; 2018)
# - Technical Guide for OpenNSPECT, Version 1.1 (2012)
# - Predicting soil erosion by water: a guide to conservation planning with the revised universal soil loss equation (RUSLE) (USDA Agriculture Handbook 703; 1997)

# NOTE: Landcover used in these functions should be a hybrid NLCD/CCAP product. Where CCAP is coded 19 (unconsolidated shore), the NLCD data should be recoded from code 31 (barren land) to code 32.
# ---------------------------------------------------------------------------

# Import modules
import HelperPro
from HelperPro import *







   
def soilLoss_RKS(in_Rfactor, in_Kfactor, in_Sfactor, out_RKS):
   '''Multiplies the rasters representing three of the factors in the Revised Universal Soil Loss Equation (RUSLE), to produce a relative measure of the propensity for soil loss. Does not include the cover management (C), slope length (L), or the  supporting practices (P) factors. Inputs must have been first generated by previous functions to produce the input rasters. 

   Parameters:
   - in_Rfactor: input raster representing the rainfall/runoff erosivity factor
   - in_Kfactor: input raster representing the soil erodibility factor
   - in_Sfactor: input raster representing the slope steepness factor
   - out_RKS: output raster representing the product of R,K, and S factors
   
   NOTE: The output can be multiplied by a C-factor raster (which depends on land cover; see OpenNSPECT documentation) OR by a constant C-factor (to obtain best-case or worst-case scenarios). The latter option is used for the Watershed Impact Model.
   
   This functions assumes all inputs are in the same coordinate system and properly aligned with each other.
   '''
   
   # Set overwrite to be true         
   arcpy.env.overwriteOutput = True
   
   # Calculate propensity for soil loss by multiplying the factors
   print("Calculating propensity for soil loss...")
   R = Raster(in_Rfactor)
   K = Raster(in_Kfactor)
   S = Raster(in_Sfactor)
   RKS = R*K*S
   
   print("Saving output...")
   RKS.save(out_RKS)
   
   print("Mission complete.")

def soilLoss_RKSC(in_RKS, in_Cfact, out_RKSC):
   '''Produces a raster representing relative soil loss, based on the RUSLE R-, K-, S-, and C-factors. 
   
   Parameters:
   - in_Raster: input raster respresenting product of the RUSLE factors RKS
   - in_Cfact: input raster or constant (float) representing the RUSLE C-factor
   - out_RKSC: output raster respresenting product of the RUSLE factors RKSC
   
   Note 1:
   For the C-factor, the Watershed Impact Model uses a constant value (0.7) to get a measure of soil loss under a "worst-case scenario" of bare land. If you want soil loss under existing land cover conditions, first create a C-factor raster based on land cover (see OpenNSPECT documentation), and use that as the input. 
   
   Note 2: This and soilLoss_RKS could have been combined into a single function for use in the Watershed Impact Model, but I kept them separate to allow greater flexibility for possible future uses, e.g., calculating changes in soil loss over time based on changing land cover.
   '''
   
   # Set overwrite to be true         
   arcpy.env.overwriteOutput = True
   
   # Set up some variables
   in_RKS = Raster(in_RKS)
   try:
      in_Cfact = Raster(in_Cfact)
   except:
      pass
   
   # Perform calculation
   print("Multiplying RKS by C-factor...")
   RKSC = in_RKS*in_Cfact
   print("Saving...")
   RKSC.save(out_RKSC)
   
   print("Mission accomplished.")

def SedYld(in_Raster, in_CurvNum, nameTag, in_Slope, out_GDB, in_Cfact = "NONE", sdrType = "STD", cellArea = 0.0001):
   '''Produces a raster representing the annual sediment yield.
   
   NOTE: The "standard" calculation for Sediment Delivery Ratio SDR is from the OpenNSPECT tech manual. I also tracked down the original paper from 1977. The equation was developed for a specific area and it is highly questionable that it should be applied anywhere else. I'm also not sure I'm using percent slope correctly to obtain ZL, the relief-length ratio. Because of my doubts about the whole thing, I developed a much simpler equation for a proxy "alternate" SDR. I don't assume any particular units can be assigned to the final sediment yield; I view both RKSC (the product of the RUSLE soil loss factors) and the final sediment yield to be relative measures only. I also left out the L-factor in RUSLE soil loss equation b/c it is difficult to calculate and maybe (probably?) not worth it.
   
   This function assumes all inputs are in the same coordinate system and properly aligned with each other.

   Parameters:
   - in_Raster: input raster respresenting product of the RUSLE factors, RKSC or RKS
   - in_CurvNum: input raster or constant (integer) representing the SCS curve number
   - nameTag: tag to add to basenames (land cover year or a scenario-based tag)
   - in_Slope: input raster representing percent slope
   - out_GDB: geodatabase to store outputs
   - in_Cfact: input raster or constant (float) representing the RUSLE C-factor. Enter "NONE" if in_Raster is RKSC (i.e., C-factor already included)
   - sdrType: Type of SDR to calculate: STD (standard) or ALT (alternate)
   - cellArea: area of cells in Curve Number raster, in square kilometers; ignored if using alternate method for SDR calculation
   '''
   
   # Set overwrite to be true         
   arcpy.env.overwriteOutput = True
   
   # Set up some variables
   out_RKSC = out_GDB + os.sep + "RKSC_%s" %nameTag
   if sdrType == "STD":
      out_SDR = out_GDB + os.sep + "SDR_%s" %nameTag
      out_SedYld = out_GDB + os.sep + "SedYld_%s" %nameTag
   else:
      out_SDR = out_GDB + os.sep + "altSDR_%s" %nameTag
      out_SedYld = out_GDB + os.sep + "altSedYld_%s" %nameTag

   try:
      in_CurvNum = Raster(in_CurvNum)
   except:
      pass
      
   in_Slope = Raster(in_Slope)
   in_Raster = Raster(in_Raster)
   
   # Perform calculations
   if in_Cfact == "NONE":
      print("Input raster is RKSC...")
      RKSC = in_Raster
   else:
      print("Input raster is RKS; multiplying by C-factor...")
      try:
         in_Cfact = Raster(in_Cfact)
      except:
         pass
      RKSC = in_Raster*in_Cfact
      print("Saving...")
      RKSC.save(out_RKSC)
   
   if sdrType == "STD":
      print("Calculating standard sediment delivery ratio...")
      print("Calculating constant Alpha...")
      Alpha = 1.366*10**(-11)
      
      print("Calculating drainage area factor...")
      D = cellArea**(-0.0998)
      
      print("Calculating slope factor...")
      Z = (in_Slope/100000.0)**0.3629 
      
      print("Calculating curve number factor...")
      N = in_CurvNum**5.444 # This may be a raster or a constant depending on input type
       
      print("Calculating sediment delivery ratio...")
      SDR = Alpha*D*Z*N
    
   else:
      print("Calculating alternate sediment delivery ratio...")
      # Adjust slope values prior to multiplying
      adjSlope = Con(in_Slope > 100, 1.0, in_Slope/100.0)
      SDR = adjSlope*in_CurvNum/100.0
      
   print("Saving...")
   SDR.save(out_SDR)
    
   print("Calculating sediment yield...")
   sedYld = RKSC*SDR
   print("Saving...")
   sedYld.save(out_SedYld)
   
   print("Mission accomplished.")  

def coeffNSPECT(in_LC, coeffType, out_Coeff):
   '''From an input land cover raster, creates a new raster representing the NSPECT coefficient type specified (coeffType). Coefficient values are from the OpenNSPECT Technical Guide. The land cover codes in that table are CCAP codes, so assignments in this function are to the equivalent NLCD codes. 
   
   The coefficients that may be specified are:
   - CFACT: The cover factor (C-Factor in the RUSLE equation; a unitless ratio)
   - NPOLL: Nitrogen pollution factor (mg/L)
   - PPOLL: Phosphorus pollution factor (mg/L)
   - SPOLL: Suspended solids pollution factor (mg/L)
   
   C-factor values are assigned to land cover classes as specified in Table 4, page 22 of the OpenNSPECT Technical Guide. The pollution coefficients are specified in Appendix A, pages 42-43.
   
   This function modifies the input land cover attribute table, by adding and calculating a new field to store the desired coefficients.

   Parameters:
   - in_LC: Input classified land cover raster, using standard NLCD land cover codes (updated with CCAP for code 32 = unconsolidated shore)
   - coeffType: The coefficient set used to produce the output
   - out_Coeff: Output raster representing specified coefficient values
   '''
   
   # Make sure user entered valid parameters, and report what they are.   
   if coeffType not in ("CFACT", "NPOLL", "PPOLL", "SPOLL"):
      print("Input coefficient type specification is invalid. Aborting.")
      sys.exit()
   
   # Set overwrite to be true         
   arcpy.env.overwriteOutput = True
   
   # Initialize empty data dictionary
   d = dict()
   
   if coeffType == "NPOLL":
      fldName = "Nitrogen"
      msg = "Adding field to store nitrogen pollution values..."
      # Nitrogen pollution dictionary
      d[11] = 0.00
      d[21] = 1.25
      d[22] = 1.77
      d[23] = 2.29
      d[24] = 2.22
      d[31] = 0.97
      d[32] = 0.97
      d[41] = 1.25
      d[42] = 1.25
      d[43] = 1.25
      d[52] = 1.25
      d[71] = 1.25
      d[81] = 2.48
      d[82] = 2.68
      d[90] = 1.10
      d[95] = 1.10
   
   elif coeffType == "PPOLL":
      fldName = "Phosphorus"
      msg = "Adding field to store phosphorus pollution values..."
      # Phosphorus pollution dictionary
      d[11] = 0.00
      d[21] = 0.05
      d[22] = 0.18
      d[23] = 0.30
      d[24] = 0.47
      d[31] = 0.12
      d[32] = 0.12
      d[41] = 0.05
      d[42] = 0.05
      d[43] = 0.05
      d[52] = 0.05
      d[71] = 0.05
      d[81] = 0.48
      d[82] = 0.42
      d[90] = 0.20
      d[95] = 0.20   
   
   elif coeffType == "SPOLL":
      fldName = "Solids"
      msg = "Adding field to store suspended solids pollution values..."
      # Suspended solids pollution dictionary
      d[11] = 0.00
      d[21] = 11.10
      d[22] = 19.10
      d[23] = 27.00
      d[24] = 71.00
      d[31] = 70.00
      d[32] = 70.00
      d[41] = 11.10
      d[42] = 11.10
      d[43] = 11.10
      d[52] = 11.10
      d[71] = 55.30
      d[81] = 55.30
      d[82] = 107.00
      d[90] = 19.00
      d[95] = 19.00  
   
   else:
      fldName = "Cfactor"
      msg = "Adding field to store C-factor values..."
      # C-factor dictionary
      d[11] = 0.000
      d[21] = 0.005
      d[22] = 0.030
      d[23] = 0.010
      d[24] = 0.000
      d[31] = 0.700
      d[32] = 0.500
      d[41] = 0.009
      d[42] = 0.004
      d[43] = 0.007
      d[52] = 0.014
      d[71] = 0.120
      d[81] = 0.005
      d[82] = 0.240
      d[90] = 0.003
      d[95] = 0.003
   
   # Create and calculate a coefficient field in the land cover attribute table
   print(msg)
   arcpy.AddField_management(in_LC, fldName, "DOUBLE")
   
   print("Calculating field...")
   codeblock = '''def coeff(code, dic):
      try: 
         val = dic[code]
      except:
         val = 0
      return val
      '''
   expression = "coeff(!VALUE!, %s)" %d
   arcpy.CalculateField_management (in_LC, fldName, expression, 'PYTHON', codeblock)
   
   # Create a new raster from the coefficient field, and save
   print("Creating raster...")
   outRaster = Lookup(in_LC, fldName)
   
   print("Saving output...")
   outRaster.save(out_Coeff)
   
   print("Mission complete.")
 
def curvNum(in_LC, in_HydroGrp, out_CN):
   '''Given input land cover and hydrologic group, produces output raster representing runoff curve numbers.
   
   Curve numbers are assigned to combinations of land cover and soil types as specified in Table 1, page 6 of the OpenNSPECT Technical Guide. 
   
   This function modifies the input land cover attribute table, by adding and calculating a new field to store the curve numbers

   Parameters:
   - in_LC: Input classified land cover raster, using standard NLCD land cover codes (updated with CCAP for code 32 = unconsolidated shore), OR an integer representing a desired land cover class
   - in_HydroGrp: Input raster representing hydrologic groups (integer values must range from 1 = A to 4 = D)
   - out_CN: Output raster representing runoff curve numbers
   '''
   
   # Set overwrite to be true         
   arcpy.env.overwriteOutput = True
   
   # Set scratch output location
   scratchGDB = arcpy.env.scratchGDB
   
   # Initialize empty data dictionaries
   dictA = dict()
   dictB = dict()
   dictC = dict()
   dictD = dict()
   m = dict()
   
   # Populate dictionary for hydro group A, then append to list
   dictA[11] = 0
   dictA[21] = 49
   dictA[22] = 61
   dictA[23] = 77
   dictA[24] = 89
   dictA[31] = 77
   dictA[32] = 0
   dictA[41] = 30
   dictA[42] = 30
   dictA[43] = 30
   dictA[52] = 30
   dictA[71] = 30
   dictA[81] = 39
   dictA[82] = 67
   dictA[90] = 0
   dictA[95] = 0
   m["A"] = dictA
   
   # Populate dictionary for hydro group B
   dictB[11] = 0
   dictB[21] = 69
   dictB[22] = 75
   dictB[23] = 85
   dictB[24] = 92
   dictB[31] = 86
   dictB[32] = 0
   dictB[41] = 55
   dictB[42] = 55
   dictB[43] = 55
   dictB[52] = 48
   dictB[71] = 58
   dictB[81] = 61
   dictB[82] = 78
   dictB[90] = 0
   dictB[95] = 0
   m["B"] = dictB
   
   # Populate dictionary for hydro group C
   dictC[11] = 0
   dictC[21] = 79
   dictC[22] = 83
   dictC[23] = 90
   dictC[24] = 94
   dictC[31] = 91
   dictC[32] = 0
   dictC[41] = 70
   dictC[42] = 70
   dictC[43] = 70
   dictC[52] = 65
   dictC[71] = 71
   dictC[81] = 74
   dictC[82] = 85
   dictC[90] = 0
   dictC[95] = 0
   m["C"] = dictC
   
   # Populate dictionary for hydro group D
   dictD[11] = 0
   dictD[21] = 84
   dictD[22] = 87
   dictD[23] = 92
   dictD[24] = 95
   dictD[31] = 94
   dictD[32] = 0
   dictD[41] = 77
   dictD[42] = 77
   dictD[43] = 77
   dictD[52] = 73
   dictD[71] = 78
   dictD[81] = 80
   dictD[82] = 89
   dictD[90] = 0
   dictD[95] = 0
   m["D"] = dictD
      
   hydroGrps = ["A", "B", "C", "D"]
   in_HydroGrp = Raster(in_HydroGrp)
   
   if type(in_LC) == str:
      # Create and calculate curve number fields in the land cover attribute table
      for grp in hydroGrps:  
         fldName = "cn_%s" %grp
         d = m[grp]
         
         fldList = arcpy.ListFields(in_LC) 
         fldNames = [f.name for f in fldList]
         if fldName in fldNames:
            print("Deleting existing field %s..." %fldName)
            arcpy.DeleteField_management (in_LC, fldName)
         
         print("Adding field %s..." %fldName)
         arcpy.AddField_management(in_LC, fldName, "SHORT")
      
         print("Calculating field...")
         codeblock = '''def curvnum(code, dic):
            try:
               cn = dic[code]
            except:
               cn = 0
            return cn
            '''
         expression = "curvnum(!VALUE!, %s)" %d
         arcpy.CalculateField_management (in_LC, fldName, expression, 'PYTHON', codeblock)
      
      # Create a new raster from the curve number fields, based on soil type
      print("Creating curve number raster...")
      outRaster = Con(in_HydroGrp == 1, Lookup(in_LC, "cn_A"), Con(in_HydroGrp == 2, Lookup(in_LC, "cn_B"), Con(in_HydroGrp == 3, Lookup(in_LC, "cn_C"),Con(in_HydroGrp == 4, Lookup(in_LC, "cn_D")))))
   
   else:
      # Use the specified land cover constant with soil type to get the curve number
      outRaster = Con(in_HydroGrp == 1, dictA[in_LC], Con(in_HydroGrp == 2, dictB[in_LC], Con(in_HydroGrp == 3, dictC[in_LC],Con(in_HydroGrp == 4, dictD[in_LC]))))
   
   print("Saving output...")
   outRaster.save(out_CN)
   
   print("Mission complete.")

def eventRunoff(in_Raster, in_Rain, out_GDB, yearTag, cellArea = 1000000, inputType = "CN", convFact = 1):
   '''Produces an output raster representing event-based runoff volume in Liters
   
   Parameters:
   - in_Raster: input raster representing curve numbers OR maximum retention
   - in_Rain: input constant or raster representing rainfall
   - out_GDB: geodatabase for storing outputs
   - yearTag: tag to add to basenames to indicate land cover year determining curve numbers 
   - cellArea: area of cells in Curve Number raster, in square centimeters
   - inputType: indicates whether in_Raster is curve numbers (CN) or retention (RET)
   - convFact: conversion factor to convert input rainfall depth units to inches
   '''
   # Set overwrite to be true         
   arcpy.env.overwriteOutput = True
   
   # Set scratch output location
   scratchGDB = arcpy.env.scratchGDB
   
   # Set up some variables
   in_Raster = Raster(in_Raster)
   try:
      in_Rain = Raster(in_Rain)
   except:
      pass
   out_Retention = out_GDB + os.sep + "Retention_%s" %yearTag
   out_runoffDepth = out_GDB + os.sep + "runoffDepth_%s" %yearTag
   out_runoffVolume = out_GDB + os.sep + "runoffVol_%s" %yearTag
   out_accumRunoff = out_GDB + os.sep + "accRunoff_%s" %yearTag

   # Perform calculations
   # Result could be raster or a constant depending on input
   if convFact != 1:
      rain = convFact*in_Rain 
   else:
      rain = in_Rain
   
   if inputType == "CN":
      print("Calculating maximum retention...")
      # Have to deal with division by zero here.
      retention = Con(in_Raster == 0, 1000, ((float(1000)/in_Raster) - 10))
      print("Saving...")
      retention.save(out_Retention)
   else:
      retention = in_Raster
   
   print("Calculating runoff depth (inches)...")
   # Set runoff depth to zero if rainfall is less than initial abstraction
   runoffDepth = Con((rain - 0.2*retention) > 0,(rain - 0.2*retention)**2/(rain + 0.8*retention),0)
   print("Saving...")
   runoffDepth.save(out_runoffDepth)
   
   print("Calculating runoff volume (liters)...")
   # 2.54 converts inches to cm
   # 0.001 converts cubic cm to liters
   volumeConversion = 0.00254*cellArea
   runoffVolume = volumeConversion*runoffDepth
   print("Saving...")
   runoffVolume.save(out_runoffVolume)
   
   # if in_FlowDir != "NONE":
      # print("Calculating runoff accumulation...")
      # accumRunoff = FlowAccumulation(in_FlowDir, runoff, "FLOAT", "D8") + runoff
      # print("Saving...")
      # accumRunoff.save(out_accumRunoff)
   # else:
      # print("No flow direction raster provided; runoff not accumulated.")
   
   print("Mission accomplished.")
 
def main():
   # Inputs - Soils
   dc_gdb = r"E:\SpatialData\SSURGO\gSSURGO_DC\gSSURGO_DC.gdb"
   de_gdb = r"E:\SpatialData\SSURGO\gSSURGO_DE\gSSURGO_DE.gdb"
   ky_gdb = r"E:\SpatialData\SSURGO\gSSURGO_KY\gSSURGO_KY.gdb"
   md_gdb = r"E:\SpatialData\SSURGO\gSSURGO_MD\gSSURGO_MD.gdb"
   nc_gdb = r"E:\SpatialData\SSURGO\gSSURGO_NC\gSSURGO_NC.gdb"
   pa_gdb = r"E:\SpatialData\SSURGO\gSSURGO_PA\gSSURGO_PA.gdb"
   tn_gdb = r"E:\SpatialData\SSURGO\gSSURGO_TN\gSSURGO_TN.gdb"
   va_gdb = r"E:\SpatialData\SSURGO\gSSURGO_VA\gSSURGO_VA.gdb"
   wv_gdb = r"E:\SpatialData\SSURGO\gSSURGO_WV\gSSURGO_WV.gdb"
   
   # Inputs - Miscellany
   in_Snap = r"E:\SpatialData\HealthyWatersWork\HW_templateRaster_Feature\HW_templateRaster.tif"
   in_Elev = r"E:\SpatialData\elev_cm.gdb\elev_cm.gdb\elev_cm_VA"
   in_clpShp = r"E:\SpatialData\HealthyWatersWork\hwProducts_20200601.gdb\HW_template_buff13k_noHoles"
   in_Rfactor = r"F:\CurrentData\R_Factor\R-Factor_CONUS.tif"
   in_pmpPts = r"E:\SpatialData\DCR_DamSafety\PMP\pmpEvalTool_v2\Output\General\PMP_64457.gdb\General_PMP_Points_64457"
   pmpFld = "PMP_24"
   
   # Outputs
   outGDB = r"E:\SpatialData\HealthyWatersWork\hwProducts_20200710.gdb" # I change this frequently   
   out_Runoff = outGDB + os.sep + "runoffScore"
   out_Erosion = outGDB + os.sep + "erosionScore"
   out_SoilSens = outGDB + os.sep + "soilSens" 
   hydroGrp = r"E:\SpatialData\HealthyWatersWork\hwProducts_20200527.gdb\hydroGroup"
   slope_perc = r"E:\SpatialData\HealthyWatersWork\hwProducts_20200626.gdb\slope_perc"
   Kfactor = r"E:\SpatialData\HealthyWatersWork\hwProducts_20200527.gdb\rusleK"
   Sfactor = r"E:\SpatialData\HealthyWatersWork\hwProducts_20200626.gdb\rusleS"
   Rfactor = r"E:\SpatialData\HealthyWatersWork\hwProducts_20200601.gdb\rusleR"
   rusleRKS = r"E:\SpatialData\HealthyWatersWork\hwProducts_20200626.gdb\rusleRKS"
   maxPrecip250 = r"E:\SpatialData\HealthyWatersWork\hwProducts_20200629.gdb\maxPrecip_gen24_topo250"
   maxPrecip10 = r"E:\SpatialData\HealthyWatersWork\hwProducts_20200629.gdb\maxPrecip_gen24_topo10"
   in_Rain = maxPrecip10
   
   # Year-specific Outputs/Inputs
   # RUSLE C-Factor
   rusleC_2016 = outGDB + os.sep + "rusleC_2016"
   rusleC_2011 = outGDB + os.sep + "rusleC_2011"
   rusleC_2006 = outGDB + os.sep + "rusleC_2006"
   rusleC_2001 = outGDB + os.sep + "rusleC_2001"   
   
   # RUSLE RKSC
   rusleRKSC_2016 = outGDB + os.sep + "rusleRKSC_2016"
   rusleRKSC_2011 = outGDB + os.sep + "rusleRKSC_2011"
   rusleRKSC_2006 = outGDB + os.sep + "rusleRKSC_2006"
   rusleRKSC_2001 = outGDB + os.sep + "rusleRKSC_2001"
   rusleRKSC_dfor = outGDB + os.sep + "rusleRKSC_dfor"
   rusleRKSC_bare = outGDB + os.sep + "rusleRKSC_bare"
   
   # Curve Numbers
   curvNum_2016 = outGDB + os.sep + "curvNum_2016"
   curvNum_2011 = outGDB + os.sep + "curvNum_2011"
   curvNum_2006 = outGDB + os.sep + "curvNum_2006"
   curvNum_2001 = outGDB + os.sep + "curvNum_2001"
   curvNum_dfor = outGDB + os.sep + "curvNum_dfor"
   curvNum_bare = outGDB + os.sep + "curvNum_bare"
   
   # Runoff Volume
   runoffVol_2016 = outGDB + os.sep + "runoffVol_2016"
   runoffVol_2011 = outGDB + os.sep + "runoffVol_2011"
   runoffVol_2006 = outGDB + os.sep + "runoffVol_2006"
   runoffVol_2001 = outGDB + os.sep + "runoffVol_2001"
   
   # Pollutant Coefficients
   Nitrogen_2016 = outGDB + os.sep + "Nitrogen_2016"
   Nitrogen_2011 = outGDB + os.sep + "Nitrogen_2011"
   Nitrogen_2006 = outGDB + os.sep + "Nitrogen_2006"
   Nitrogen_2001 = outGDB + os.sep + "Nitrogen_2001"
   Phosphorus_2016 = outGDB + os.sep + "Phosphorus_2016"
   Phosphorus_2011 = outGDB + os.sep + "Phosphorus_2011"
   Phosphorus_2006 = outGDB + os.sep + "Phosphorus_2006"
   Phosphorus_2001 = outGDB + os.sep + "Phosphorus_2001"
   SuspSolids_2016 = outGDB + os.sep + "SuspSolids_2016"
   SuspSolids_2011 = outGDB + os.sep + "SuspSolids_2011"
   SuspSolids_2006 = outGDB + os.sep + "SuspSolids_2006"
   SuspSolids_2001 = outGDB + os.sep + "SuspSolids_2001"
   
   # Processing Lists/Dictionaries
   gdbList = [dc_gdb, de_gdb, ky_gdb, md_gdb, nc_gdb, pa_gdb, tn_gdb, va_gdb, wv_gdb]
   testList = [dc_gdb]
   
   nlcdDict = dict()
   nlcdDict[2016] = r"E:\SpatialData\NLCD_landCover.gdb\nlcd_ccap_2016_10m"
   nlcdDict[2011] = r"E:\SpatialData\NLCD_landCover.gdb\nlcd_ccap_2011_10m"
   nlcdDict[2006] = r"E:\SpatialData\NLCD_landCover.gdb\nlcd_ccap_2006_10m"
   nlcdDict[2001] = r"E:\SpatialData\NLCD_landCover.gdb\nlcd_ccap_2001_10m"
   
   ### Specify function(s) to run
   createFGDB(outGDB) # Create the specified outGDB if it doesn't already exist
   
   ### Create NSPECT pollution coefficient rasters
   print("Creating year-specific NSPECT pollution coefficient rasters...")
   nDict = dict()
   pDict = dict()
   sDict = dict()
   coeffList = [["Nitrogen", "NPOLL", nDict], 
            ["Phosphorus", "PPOLL", pDict], 
            ["SuspSolids", "SPOLL", sDict]]
   for year in nlcdDict.keys():
      print("Working on %s data..." %year)
      for coeff in coeffList:
         rName = coeff[0]
         coeffType = coeff[1]
         coeffDict = coeff[2]
         out_Coeff = outGDB + os.sep + "%s_%s" %(rName, year)
         coeffNSPECT(nlcdDict[year], coeffType, out_Coeff)
         coeffDict[year] = out_Coeff
   
   ### Create curve number rasters
   SSURGOtoRaster(gdbList, "HydroGrpNum", in_Snap, hydroGrp)
   print("Creating year-specific Curve Number rasters...")
   cnDict = dict()
   for year in nlcdDict.keys():
      print("Working on %s data..." %year)
      in_LC = nlcdDict[year]
      out_CN = outGDB + os.sep + "curvNum_%s" %year
      curvNum(in_LC, hydroGrp, out_CN)
      cnDict[year] = out_CN
      
   ### Create RUSLE factors
   print("Creating year-specific C-factors...")
   cfactDict = dict()
   for year in nlcdDict.keys():
      print("Working on %s data..." %year)
      in_LC = nlcdDict[year]
      out_Cfactor = outGDB + os.sep + "rusleC_%s" %year
      coeffNSPECT(in_LC, "CFACT", out_Cfactor)
      cfactDict[year] = out_Cfactor
   print("Downscaling R-factor...")
   Downscale_ras(in_Rfactor, in_Snap, Rfactor, "BILINEAR", in_clpShp) # R-factor
   print("Creating K-factor raster...")
   SSURGOtoRaster(gdbList, "kFactor", in_Snap, Kfactor) # K-factor
   print("Creating S-factor raster...")
   SlopeTrans(in_Elev, "ELEV", "RUSLE", Sfactor, slope_perc, zfactor = 0.01) # S-factor
   print("Creating RKS raster...")
   soilLoss_RKS(Rfactor, Kfactor, Sfactor, rusleRKS) # R*K*S
   
   ### Get Probable Maximum Precipitation
   # First had to use the PMP tool(https://www.dcr.virginia.gov/dam-safety-and-floodplains/pmp-tool) from within ArcGIS Pro to generate the points used for interpolation. I specified a 24-hour storm duration, and used the "General" output.
   # arcpy.ImportToolbox(r'E:\SpatialData\DCR_DamSafety\PMP\pmpEvalTool_v2\Script\VA_PMP_Tools_v2.tbx','')
   # arcpy..PMPCalc(r"E:\SpatialData\HW_templateRaster_Feature\HW_templateFeature.shp", r"E:\SpatialData\DCR_DamSafety\PMP\pmpEvalTool_v2", r"E:\SpatialData\DCR_DamSafety\PMP\pmpEvalTool_v2\Output", "24", "24", "24", True, None)
   interpPoints(in_pmpPts, pmpFld, in_Snap, maxPrecip250, in_clpShp, "TOPO", "", "", 250)
   Downscale_ras(maxPrecip250, in_Snap, maxPrecip10, "BILINEAR", in_clpShp)
   
   ### Create runoff, pollution, and sediment yield rasters
   print("Creating year-specific runoff, pollution, and sediment yield rasters...")
   runoffDict = dict()
   nMassDict = dict()
   pMassDict = dict()
   sMassDict = dict()
   pollutantList = [["Nitrogen", nDict, nMassDict], 
            ["Phosphorus", pDict, pMassDict], 
            ["SuspSolids", sDict, sMassDict ]]
   for year in nlcdDict.keys():
      print("Working on %s data..." %year)
      CN = cnDict[year]
      cFact = cfactDict[year]
      print("Calculating runoff...")
      eventRunoff(CN, in_Rain, outGDB, year, 1000000, "CN")
      runoffDict[year] = outGDB + os.sep + "runoffVol_%s" %year
      for pollutant in pollutantList:
         rName = pollutant[0]
         coeffDict = pollutant[1]
         massDict = pollutant[2]
         out_Raster = outGDB + os.sep + "LocMass_%s_%s"%(rName, year)
         print("Calculating %s mass..."%rName)
         pollMass = Raster(coeffDict[year])*Raster(runoffDict[year])
         pollMass.save(out_Raster)
         massDict[year] = out_Raster
      print("Calculating standard sediment yield...")
      SedYld(rusleRKS, CN, year, slope_perc, outGDB, cFact, sdrType = "STD", cellArea = 0.0001)
      print("Calculating alternate sediment yield...")
      SedYld(rusleRKS, CN, year, slope_perc, outGDB, cFact, sdrType = "ALT")
   
   ### Get "worst-case" (bare land, NLCD code 31, C-factor = 0.700) and "best-case" (deciduous forest, NLCD code 41, C-factor = 0.009) scenarios for curve numbers, runoff, and sedimentation. These are not necessarily the best or worst (e.g., wetlands are even better than deciduous forest) but serve the purpose here.
   print("Calculating best- and worst-case curve numbers...")
   curvNum(41, hydroGrp, curvNum_dfor)
   curvNum(31, hydroGrp, curvNum_bare)
   # Event runoff
   print("Calculating best-and worst-case runoff...")
   eventRunoff(curvNum_dfor, in_Rain, outGDB, "dfor")
   eventRunoff(curvNum_bare, in_Rain, outGDB, "bare")
   # Soil loss potential
   print("Calculating best- and worst-case soil loss potential...")
   soilLoss_RKSC(rusleRKS, 0.009, rusleRKSC_dfor)
   soilLoss_RKSC(rusleRKS, 0.700, rusleRKSC_bare)
   print("Mission accomplished.")
   
if __name__ == '__main__':
   main()
